(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{792:function(e,t,r){"use strict";r.r(t);var a=r(1),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"concepts"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" Concepts")]),e._v(" "),r("h2",{attrs:{id:"eoa"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#eoa"}},[e._v("#")]),e._v(" EOA")]),e._v(" "),r("p",[e._v("An Externally Owned Account ("),r("a",{attrs:{href:"https://ethereum.org/en/whitepaper/#ethereum-accounts",target:"_blank",rel:"noopener noreferrer"}},[e._v("EOA"),r("OutboundLink")],1),e._v(") is an account controlled by a private key, that can sign transactions.")]),e._v(" "),r("h2",{attrs:{id:"deployer-address"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deployer-address"}},[e._v("#")]),e._v(" Deployer Address")]),e._v(" "),r("p",[e._v("The EOA address that deployed the smart contract being registered for fee distribution.")]),e._v(" "),r("h2",{attrs:{id:"withdraw-address"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#withdraw-address"}},[e._v("#")]),e._v(" Withdraw Address")]),e._v(" "),r("p",[e._v("The address set by a contract deployer to receive transaction fees for a registered smart contract. If not set, it defaults to the deployer’s address.")]),e._v(" "),r("h2",{attrs:{id:"developer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#developer"}},[e._v("#")]),e._v(" Developer")]),e._v(" "),r("p",[e._v("The entity that has control over the deployer account.")]),e._v(" "),r("h2",{attrs:{id:"registration-of-a-contract"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#registration-of-a-contract"}},[e._v("#")]),e._v(" Registration of a Contract")]),e._v(" "),r("p",[e._v("Any contract can be registered by a developer by submitting a signed transaction. The signer of this transaction must match the address of the deployer of the contract in order for the registration to succeed. After the transaction is executed successfully, the developer will start receiving a portion of the transaction fees paid when a user interacts with the registered contract.")]),e._v(" "),r("h3",{attrs:{id:"fee-distribution"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fee-distribution"}},[e._v("#")]),e._v(" Fee Distribution")]),e._v(" "),r("p",[e._v("As described above, developers will earn a portion of the transaction fee after they register their contracts. The transactions eligible are only EVM transactions ("),r("code",[e._v("MsgEthereumTx")]),e._v("). Cosmos SDK transactions are not eligible at this time.")]),e._v(" "),r("h4",{attrs:{id:"evm-transaction-fees"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#evm-transaction-fees"}},[e._v("#")]),e._v(" EVM Transaction Fees")]),e._v(" "),r("p",[e._v("When a transaction is executed, the entire fee amount "),r("code",[e._v("gasLimit * gasPrice")]),e._v(" is sent to the "),r("code",[e._v("FeeCollector")]),e._v(" Module Account during the "),r("code",[e._v("AnteHandler")]),e._v(" execution. After the EVM executes the transaction, the user receives a refund of "),r("code",[e._v("(gasLimit - gasUsed) * gasPrice")]),e._v(".")]),e._v(" "),r("p",[e._v("Therefore, the user only pays for the execution: "),r("code",[e._v("txFee = gasUsed * gasPrice")]),e._v(". This is the transaction fee distributed between developers and validators, in accordance with the "),r("code",[e._v("x/fees")]),e._v(" module parameters: "),r("code",[e._v("DeveloperShares")]),e._v(", "),r("code",[e._v("ValidatorShares")]),e._v(". This distribution is handled through the "),r("code",[e._v("PostTxProcessing")]),e._v(" "),r("RouterLink",{attrs:{to:"/modules/fees/05_hooks.html"}},[e._v("Hook")]),e._v(".")],1),e._v(" "),r("h3",{attrs:{id:"address-derivation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#address-derivation"}},[e._v("#")]),e._v(" Address Derivation")]),e._v(" "),r("p",[e._v("When registering a smart contract, the deployer provides an array of nonces, used to "),r("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/blob/d8ff53dfb8a516f47db37dbc7fd7ad18a1e8a125/crypto/crypto.go#L107-L111",target:"_blank",rel:"noopener noreferrer"}},[e._v("derive the contract’s address"),r("OutboundLink")],1),e._v(". The smart contract can be directly deployed by the deployer's EOA or created through one or more "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Factory_method_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("factory"),r("OutboundLink")],1),e._v(" pattern smart contracts.")]),e._v(" "),r("p",[e._v("If "),r("code",[e._v("MyContract")]),e._v(" is deployed directly by "),r("code",[e._v("DeployerEOA")]),e._v(", in a transaction sent with nonce "),r("code",[e._v("5")]),e._v(", then the array of nonces is "),r("code",[e._v("[5]")]),e._v(".")]),e._v(" "),r("p",[e._v("If the contract was created by a smart contract, through the "),r("code",[e._v("CREATE")]),e._v(" opcode, we need to provide all the nonces from the creation path. Let's take the example of "),r("code",[e._v("DeployerEOA")]),e._v(" deploying a "),r("code",[e._v("Factory0")]),e._v(" smart contract with nonce "),r("code",[e._v("5")]),e._v(". Then, "),r("code",[e._v("DeployerEOA")]),e._v(" sends a transaction to "),r("code",[e._v("Factory0")]),e._v(" through which a "),r("code",[e._v("Factory1")]),e._v(" smart contract is created. Let us assume "),r("code",[e._v("Factory1")]),e._v(" is the second contract created by "),r("code",[e._v("Factory0")]),e._v(" - the nonce is "),r("code",[e._v("1")]),e._v(". Then, "),r("code",[e._v("DeployerEOA")]),e._v(" sends a transaction to the "),r("code",[e._v("Factory1")]),e._v(" contract, through which "),r("code",[e._v("MyContract")]),e._v(" is created. Let us assume this is the first contract created by "),r("code",[e._v("Factory1")]),e._v(" - the nonce is "),r("code",[e._v("0")]),e._v(". We now have an address derivation path of "),r("code",[e._v("DeployerEOA")]),e._v(" -> "),r("code",[e._v("Factory0")]),e._v(" -> "),r("code",[e._v("Factory1")]),e._v(" -> "),r("code",[e._v("MyContract")]),e._v(". To be able to verify that "),r("code",[e._v("DeployerEOA")]),e._v(" can register "),r("code",[e._v("MyContract")]),e._v(", we need to provide the following nonces: "),r("code",[e._v("[5, 1, 0]")]),e._v(".")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",[r("strong",[e._v("Note")]),e._v(": Even if "),r("code",[e._v("MyContract")]),e._v(" is created from "),r("code",[e._v("Factory1")]),e._v(" through a transaction sent by an account different from "),r("code",[e._v("DeployerEOA")]),e._v(", only "),r("code",[e._v("DeployerEOA")]),e._v(" can register "),r("code",[e._v("MyContract")]),e._v(".")])])])}),[],!1,null,null,null);t.default=o.exports}}]);