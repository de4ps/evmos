(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{810:function(e,n,t){"use strict";t.r(n);var i=t(1),o=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" Concepts")]),e._v(" "),t("h2",{attrs:{id:"client-misbehaviour"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#client-misbehaviour"}},[e._v("#")]),e._v(" Client Misbehaviour")]),e._v(" "),t("p",[e._v("IBC clients must freeze when the counterparty chain becomes byzantine and\ntakes actions that could fool the light client into accepting invalid state\ntransitions. Thus, relayers are able to submit Misbehaviour proofs that prove\nthat a counterparty chain has signed two Headers for the same height. This\nconstitutes misbehaviour as the IBC client could have accepted either header\nas valid. Upon verifying the misbehaviour the IBC client must freeze at that\nheight so that any proof verifications for the frozen height or later fail.")]),e._v(" "),t("p",[e._v("Note, there is a difference between the chain-level Misbehaviour that IBC is\nconcerned with and the validator-level Evidence that Tendermint is concerned\nwith. Tendermint must be able to detect, submit, and punish any evidence of\nindividual validators breaking the Tendermint consensus protocol and attempting\nto mount an attack. IBC clients must only act when an attack is successful\nand the chain has successfully forked. In this case, valid Headers submitted\nto the IBC client can no longer be trusted and the client must freeze.")]),e._v(" "),t("p",[e._v("Governance may then choose to override a frozen client and provide the correct,\ncanonical Header so that the client can continue operating after the Misbehaviour\nsubmission.")]),e._v(" "),t("h2",{attrs:{id:"connection-handshake"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#connection-handshake"}},[e._v("#")]),e._v(" Connection Handshake")]),e._v(" "),t("p",[e._v("The connection handshake occurs in 4 steps as defined in "),t("a",{attrs:{href:"https://github.com/cosmos/ibc/blob/master/spec/core/ics-003-connection-semantics",target:"_blank",rel:"noopener noreferrer"}},[e._v("ICS 03"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[t("code",[e._v("ConnOpenInit")]),e._v(" is the first attempt to initialize a connection on the executing chain.\nThe handshake is expected to succeed if the version selected is supported. The connection\nidentifier for the counterparty connection must be left empty indicating that the counterparty\nmust select its own identifier. The connection identifier is auto derived in the format:\n"),t("code",[e._v("connection{N}")]),e._v(" where N is the next sequence to be used. The counter begins at 0 and increments\nby 1. The connection is set and stored in the INIT state upon success.")]),e._v(" "),t("p",[t("code",[e._v("ConnOpenTry")]),e._v(" is a response to a chain executing "),t("code",[e._v("ConnOpenInit")]),e._v(". The executing chain will validate\nthe chain level parameters the counterparty has stored such as its chainID. The executing chain\nwill also verify that if a previous connection exists for the specified connection identifier\nthat all the parameters match and its previous state was in INIT. This may occur when both\nchains execute "),t("code",[e._v("ConnOpenInit")]),e._v(" simultaneously. If the connection does not exist then a connection\nidentifier is generated in the same format done in "),t("code",[e._v("ConnOpenInit")]),e._v(".  The executing chain will verify\nthat the counterparty created a connection in INIT state. The executing chain will also verify\nThe "),t("code",[e._v("ClientState")]),e._v(" and "),t("code",[e._v("ConsensusState")]),e._v(" the counterparty stores for the executing chain. The\nexecuting chain will select a version from the intersection of its supported versions and the\nversions set by the counterparty. The connection is set and stored in the TRYOPEN state upon\nsuccess.")]),e._v(" "),t("p",[t("code",[e._v("ConnOpenAck")]),e._v(" may be called on a chain when the counterparty connection has entered TRYOPEN. A\nprevious connection on the executing chain must exist in either INIT or TRYOPEN. The executing\nchain will verify the version the counterparty selected. If the counterparty selected its own\nconnection identifier, it will be validated in the basic validation of a "),t("code",[e._v("MsgConnOpenAck")]),e._v(".\nThe counterparty connection state is verified along with the "),t("code",[e._v("ClientState")]),e._v(" and "),t("code",[e._v("ConsensusState")]),e._v("\nstored for the executing chain. The connection is set and stored in the OPEN state upon success.")]),e._v(" "),t("p",[t("code",[e._v("ConnOpenConfirm")]),e._v(" is a response to a chain executing "),t("code",[e._v("ConnOpenAck")]),e._v(". The executing chain's connection\nmust be in TRYOPEN. The counterparty connection state is verified to be in the OPEN state. The\nconnection is set and stored in the OPEN state upon success.")]),e._v(" "),t("h2",{attrs:{id:"connection-version-negotiation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#connection-version-negotiation"}},[e._v("#")]),e._v(" Connection Version Negotiation")]),e._v(" "),t("p",[e._v("During the handshake procedure for connections a version is agreed\nupon between the two parties. This occurs during the first 3 steps of the\nhandshake.")]),e._v(" "),t("p",[e._v("During "),t("code",[e._v("ConnOpenInit")]),e._v(", party A is expected to set all the versions they wish\nto support within their connection state. It is expected that this set of\nversions is from most preferred to least preferred. This is not a strict\nrequirement for the SDK implementation of IBC because the party calling\n"),t("code",[e._v("ConnOpenTry")]),e._v(" will greedily select the latest version it supports that the\ncounterparty supports as well. A specific version can optionally be passed\nas "),t("code",[e._v("Version")]),e._v(" to ensure that the handshake will either complete with that\nversion or fail.")]),e._v(" "),t("p",[e._v("During "),t("code",[e._v("ConnOpenTry")]),e._v(", party B will select a version from the counterparty's\nsupported versions. Priority will be placed on the latest supported version.\nIf a matching version cannot be found an error is returned.")]),e._v(" "),t("p",[e._v("During "),t("code",[e._v("ConnOpenAck")]),e._v(", party A will verify that they can support the version\nparty B selected. If they do not support the selected version an error is\nreturned. After this step, the connection version is considered agreed upon.")]),e._v(" "),t("p",[e._v("A "),t("code",[e._v("Version")]),e._v(" is defined as follows:")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBWZXJzaW9uIHN0cnVjdCB7CgkvLyB1bmlxdWUgdmVyc2lvbiBpZGVudGlmaWVyCglJZGVudGlmaWVyIHN0cmluZyAKCS8vIGxpc3Qgb2YgZmVhdHVyZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllcgoJRmVhdHVyZXMgW11zdHJpbmcgCn0K"}}),e._v(" "),t("p",[e._v("A version must contain a non empty identifier. Empty feature sets are allowed, but each\nfeature must be a non empty string.")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",[e._v("A set of versions should not contain two versions with the same\nidentifier, but differing feature sets. This will result in undefined behavior\nwith regards to version selection in "),t("code",[e._v("ConnOpenTry")]),e._v(". Each version in a set of\nversions should have a unique version identifier.")])]),e._v(" "),t("h2",{attrs:{id:"channel-version-negotiation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#channel-version-negotiation"}},[e._v("#")]),e._v(" Channel Version Negotiation")]),e._v(" "),t("p",[e._v("During the channel handshake procedure a version must be agreed upon between\nthe two parties. The selection process is largely left to the callers and\nthe verification of valid versioning must be handled by application developers\nin the channel handshake callbacks.")]),e._v(" "),t("p",[e._v("During "),t("code",[e._v("ChanOpenInit")]),e._v(", a version string is passed in and set in party A's\nchannel state.")]),e._v(" "),t("p",[e._v("During "),t("code",[e._v("ChanOpenTry")]),e._v(", a version string for party A and for party B are passed\nin. The party A version string must match the version string used in\n"),t("code",[e._v("ChanOpenInit")]),e._v(" otherwise channel state verification will fail. The party B\nversion string could be anything (even different than the proposed one by\nparty A). However, the proposed version by party B is expected to be fully\nsupported by party A.")]),e._v(" "),t("p",[e._v("During the "),t("code",[e._v("ChanOpenAck")]),e._v(" callback, the application module is expected to verify\nthe version proposed by party B using the "),t("code",[e._v("MsgChanOpenAck")]),e._v(" "),t("code",[e._v("CounterpartyVersion")]),e._v("\nfield. The application module should throw an error if the version string is\nnot valid.")]),e._v(" "),t("p",[e._v("In general empty version strings are to be considered valid options for an\napplication module.")]),e._v(" "),t("p",[e._v("Application modules may implement their own versioning system, such as semantic\nversioning, or they may lean upon the versioning system used for in connection\nversion negotiation. To use the connection version semantics the application\nwould simply pass the proto encoded version into each of the handshake calls\nand decode the version string into a "),t("code",[e._v("Version")]),e._v(" instance to do version verification\nin the handshake callbacks.")]),e._v(" "),t("p",[e._v("Implementations which do not feel they would benefit from versioning can do\nbasic string matching using a single compatible version.")]),e._v(" "),t("h2",{attrs:{id:"sending-receiving-acknowledging-packets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sending-receiving-acknowledging-packets"}},[e._v("#")]),e._v(" Sending, Receiving, Acknowledging Packets")]),e._v(" "),t("p",[e._v("Terminology:\n"),t("strong",[e._v("Packet Commitment")]),e._v(" A hash of the packet stored on the sending chain.\n"),t("strong",[e._v("Packet Receipt")]),e._v(" A single bit indicating that a packet has been received.\nUsed for timeouts.\n"),t("strong",[e._v("Acknowledgement")]),e._v(" Data written to indicate the result of receiving a packet.\nTypically conveying either success or failure of the receive.")]),e._v(" "),t("p",[e._v("A packet may be associated with one of the following states:")]),e._v(" "),t("ul",[t("li",[e._v("the packet does not exist (ie it has not been sent)")]),e._v(" "),t("li",[e._v("the packet has been sent but not received (the packet commitment exists on the\nsending chain, but no receipt exists on the receiving chain)")]),e._v(" "),t("li",[e._v("the packet has been received but not acknowledged (packet commitment exists\non the sending chain, a receipt exists on the receiving chain, but no acknowledgement\nexists on the receiving chain)")]),e._v(" "),t("li",[e._v("the packet has been acknowledgement but the acknowledgement has not been relayed\n(the packet commitment exists on the sending chain, the receipt and acknowledgement\nexist on the receiving chain)")]),e._v(" "),t("li",[e._v("the packet has completed its life cycle (the packet commitment does not exist on\nthe sending chain, but a receipt and acknowledgement exist on the receiving chain)")])]),e._v(" "),t("p",[e._v("Sending of a packet is initiated by a call to the "),t("code",[e._v("ChannelKeeper.SendPacket")]),e._v("\nfunction by an application module. Packets being sent will be verified for\ncorrectness (core logic only). If the packet is valid, a hash of the packet\nwill be stored as a packet commitment using the packet sequence in the key.\nPacket commitments are stored on the sending chain.")]),e._v(" "),t("p",[e._v("A message should be sent to the receving chain indicating that the packet\nhas been committed on the sending chain and should be received on the\nreceiving chain. The light client on the receiving chain, which verifies\nthe sending chain's state, should be updated to the lastest sending chain\nstate if possible. The verification will fail if the latest state of the\nlight client does not include the packet commitment. The receiving chain\nis responsible for verifying that the counterparty set the hash of the\npacket. If verification of the packet to be received is successful, the\nreceiving chain should store a receipt of the packet and call application\nlogic if necessary. An acknowledgement may be processed and stored at this time (synchronously)\nor at another point in the future (asynchronously).")]),e._v(" "),t("p",[e._v("Acknowledgements written on the receiving chain may be verified on the\nsending chain. If the sending chain successfully verifies the acknowledgement\nthen it may delete the packet commitment stored at that sequence. There is\nno requirement for acknowledgements to be written. Only the hash of the\nacknowledgement is stored on the chain. Application logic may be executed\nin conjunction with verifying an acknowledgement. For example, in fungible\ncross-chain token transfer, a failed acknowledgement results in locked or\nburned funds being refunded.")]),e._v(" "),t("p",[e._v("Relayers are responsible for reconstructing packets between the sending,\nreceiving, and acknowledging of packets.")]),e._v(" "),t("p",[e._v("IBC applications sending and receiving packets are expected to appropriately\nhandle data contained within a packet. For example, cross-chain token\ntransfers will unmarshal the data into proto definitions representing\na token transfer.")]),e._v(" "),t("p",[e._v("Future optimizations may allow for storage cleanup. Stored packet\ncommitments could be removed from channels which do not write\npacket acknowledgements and acknowledgements could be removed\nwhen a packet has completed its life cycle.")]),e._v(" "),t("p",[e._v("on channel closure will additionally verify that the counterparty channel has\nbeen closed. A successful timeout may execute application logic as appropriate.")]),e._v(" "),t("p",[e._v("Both the packet's timeout timestamp and the timeout height must have been\nsurpassed on the receiving chain for a timeout to be valid. A timeout timestamp\nor timeout height with a 0 value indicates the timeout field may be ignored.\nEach packet is required to have at least one valid timeout field.")])],1)}),[],!1,null,null,null);n.default=o.exports}}]);